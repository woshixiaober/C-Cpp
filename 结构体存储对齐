一个结构体变量定义完之后，其在内存中的存储大学并不等于其所包含元素的宽度之和。

例1：
                  struct X
                  {
                    char a;
                    int b;
                    double c;
                  }S1;

                  void main()
                  {
                    cout << sizeof(S1) << endl;
                    cout << sizeof(S1.a) << endl;
                    cout << sizeof(S1.b) << endl;
                    cout << sizeof(S1.c) << endl;
                  }

 比如例一中的结构体变量S1定义之后，经测试，会发现sizeof(S1）= 16，
 其值不等于sizeof(S1.a) = 1、sizeof(S1.b) = 4和 sizeof(S1.c) = 8三者之和，这里面就存在存储对齐问题。
 
 原则一：结构体中元素是按照定义顺序一个一个放到内存中去的，但并不是紧密排列的。
        从结构体存储的首地址开始，每一个元素放置到内存中时，它都会认为内存是以它自己的大小来划分的，
        因此元素放置的位置一定会在自己宽度的整数倍上开始（以结构体变量首地址为0计算）。
0    a(char:1B)
1
2
3
4    b(int 4B)
5
6
7
8    c(double 8B)
9
10
11
12
13
14
15

例2：
             struct X
              {
                  char a;
                  double b;
                  int c;
              }S2;
在例二中仅仅是将double型的变量和int型的变量互换了位置。
测试程序不变，测试结果却截然不同，sizeof(S2)=24，不同于我们按照原则一计算出的8+8+4=20，这就引出了我们的第二原则。

原则二：在经过第一原则分析后，检查计算出的存储单元是否为所有元素中最宽的元素的长度的整数倍，
       是，则结束；若不是，则补齐为它的整数倍
       
例二中，我们分析完后的存储长度为20字节，不是最宽元素长度8的整数倍，因此将它补齐到8的整数倍，也就是24。这样就没问题了。

例3：
      struct X
      { 
         double a;
         char b;
         int c;
         char d;   
      }S4;
仍然首先按照第一原则分析，得到的字节数为8+4+4+1=17；再按照第二原则补齐，则结构体变量S4所占存储空间为24。


参考博客：结构体在内存中的存储方式 https://www.cnblogs.com/TYH-TYH/p/8021908.html



